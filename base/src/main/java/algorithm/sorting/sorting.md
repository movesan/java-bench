# 排序总览

排序算法 | 平均时间复杂度 | 最佳情况 | 最坏情况 | 空间复杂度 | 排序方式（原地） | 稳定 
:-: | :-: | :-: | :-: |:-: |--- |:-: 
冒泡排序 | O(n^2) | O(n) | O(n^2) | O(1) | In-place | 是 
选择排序 | O(n^2) | O(n^2) | O(n^2) | O(1) | In-place | 否 
插入排序 | O(n^2) | O(n) | O(n^2) | O(1) | In-place | 是 
希尔排序 | O(nlog^2*n) | O(nlog^2*n) | O(nlog^2*n) | O(1) | In-place | 否 
归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | Out-place | 是 
快速排序 | O(nlogn) | O(nlogn) | O(n^2) | O(logn) | In-place | 否 
  桶排序  |     O(n+k)     |    O(n)     |   O(n^2)    |   O(n+k)   | Out-place | 是 
计数排序 | O(n+k) | O(n+k) | O(n+k) | O(k) | Out-place | 是 
基数排序 | O(dn) | O(dn) | O(dn) | O(n+d) | Out-place | 是 

- n: 代表数据规模及数据量大小
- k: 数据范围
- d: 维度
- In-place: 不占用额外内存，只占用常数内存
- Out-place: 占用额外内存



# 基础排序

### 冒泡排序

**原理**：两两比较，进行交换

**优化**：当某次操作没有数据交换时，不再继续后面的冒泡操作

**特点**：交换次数是一个固定值，优化空间小

### 选择排序

**原理**：两个区间，已排序；未排序。每次找到未排序区间最小值，放到已排序区间末尾

**优化**：

**特点**：

### 插入排序

**原理**：两个区间，已排序；未排序。遍历未排序区间，每次将元素插入到已排序区间的对应位置

**优化**：

**特点**：优化空间大

### 希尔排序

**原理**：插入排序的优化版本，插入排序如果数据大体有序，将会很快，所以希尔排序就是为了让数据整体有序。

**优化**：

**特点**：



# 进阶排序

### 归并排序

**原理**：分治思想，递归排序。将待排序区间递归分组，合并的时候使有序

**优化**：如果分组元素小于一定值，则改为插入排序使单个分组有序

**特点**：时间复杂度稳定，空间复杂度高

### 快速排序

**原理**：分治思想，递归排序。如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。选取pivot将待排序区间整体有序分组，即（左边区间最大的元素不大于右边区间），直至最后不能再分则单个区间有序，直接合并有序区间

**优化**：如果分组元素小于一定值，则改为插入排序使单个分组有序

**特点**：性能高



# 线性排序

### 桶排序

**原理**：将数据分成几个桶，分别对单个桶排序，划分时保证每个桶之间的数据为天然有序，合并时就无需再次排序

单个桶的排序可采用快排等

**优化**：

**特点**：对大数据量效果好，对数据要求苛刻，可以均匀划分为多个桶，并且天然有序

### 计数排序

**原理**：计数排序其实是桶排序的一种特殊情况。当数据范围很小时，如k个数据，可划分为k个桶，每个桶中的数据相等，这样桶内数据就无需排序

**优化**：

**特点**：数据范围不大的场景中，

### 基数排序

**原理**：根据每一位来进行排序。如比较手机号码，先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。

借助桶排序或者计数排序来完成每一个位的排序工作

**优化**：

**特点**：基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。